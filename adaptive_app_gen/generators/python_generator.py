"""
Python specific project generator
"""

from pathlib import Path
from typing import Dict, Any
import logging

logger = logging.getLogger(__name__)


class PythonProjectGenerator:
    """Generates production-ready Python projects"""
    
    @staticmethod
    def get_project_structure(spec: Dict[str, Any]) -> Dict[str, str]:
        """Get standard Python project structure"""
        app_name = spec.get("name", "app").replace("-", "_")
        
        return {
            f"{app_name}": "Main package",
            f"{app_name}/core": "Core functionality",
            f"{app_name}/config": "Configuration",
            f"{app_name}/utils": "Utility functions",
            "tests": "Test suite",
            "tests/unit": "Unit tests",
            "tests/integration": "Integration tests",
            "docs": "Documentation",
            ".github/workflows": "GitHub Actions CI/CD",
        }
    
    @staticmethod
    def generate_setup_py(spec: Dict[str, Any]) -> str:
        """Generate setup.py for the Python package"""
        app_name = spec.get("name", "app")
        description = spec.get("description", "")
        dependencies = spec.get("dependencies", [])
        
        deps_str = ",\n        ".join([f'"{dep}"' for dep in dependencies])
        
        setup_py = f'''"""
Setup configuration for {app_name}
"""

from setuptools import setup, find_packages

setup(
    name="{app_name}",
    version="1.0.0",
    description="{description}",
    author="Generated by Bedrock",
    author_email="noreply@example.com",
    license="MIT",
    packages=find_packages(exclude=["tests", "tests.*"]),
    python_requires=">=3.9",
    install_requires=[
        {deps_str if deps_str else "'requests'"}
    ],
    extras_require={{
        "dev": [
            "pytest>=7.0",
            "pytest-cov>=4.0",
            "black>=23.0",
            "flake8>=5.0",
            "mypy>=1.0",
            "sphinx>=5.0",
        ],
        "test": [
            "pytest>=7.0",
            "pytest-cov>=4.0",
            "pytest-mock>=3.0",
        ],
    }},
    entry_points={{
        "console_scripts": [
            "{app_name}={app_name}.cli:main",
        ],
    }},
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
    ],
)
'''
        return setup_py
    
    @staticmethod
    def generate_pyproject_toml(spec: Dict[str, Any]) -> str:
        """Generate pyproject.toml for the Python package"""
        app_name = spec.get("name", "app")
        description = spec.get("description", "")
        
        pyproject = f'''[build-system]
requires = ["setuptools>=65.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "{app_name}"
version = "1.0.0"
description = "{description}"
readme = "README.md"
requires-python = ">=3.9"
license = {{text = "MIT"}}
authors = [
    {{name = "Generated by Bedrock", email = "noreply@example.com"}}
]
keywords = ["generated", "bedrock", "aws"]

[project.urls]
Homepage = "https://github.com/yourusername/{app_name}"
Documentation = "https://github.com/yourusername/{app_name}/docs"
Repository = "https://github.com/yourusername/{app_name}.git"
"Bug Tracker" = "https://github.com/yourusername/{app_name}/issues"

[tool.setuptools]
packages = ["setuptools.find_packages"]

[tool.black]
line-length = 100
target-version = ["py39", "py310", "py311"]
include = "\\\\.pyi?$"
exclude = "(.git|__pycache__|.mypy_cache|.tox|.venv|_build|buck-out|build|dist)"

[tool.isort]
profile = "black"
multi_line_mode = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true
line_length = 100

[tool.mypy]
python_version = "3.9"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = false

[tool.pytest.ini_options]
testpaths = ["tests"]
addopts = "-v --cov={app_name} --cov-report=html --cov-report=term-missing"
python_files = ["test_*.py", "*_test.py"]
'''
        return pyproject
    
    @staticmethod
    def generate_requirements_txt(spec: Dict[str, Any]) -> str:
        """Generate requirements.txt"""
        dependencies = spec.get("dependencies", [])
        
        requirements = "# Generated Python Dependencies\n"
        requirements += "# Core Dependencies\n"
        
        for dep in dependencies:
            requirements += f"{dep}\n"
        
        requirements += "\n# Development Dependencies\n"
        requirements += "pytest>=7.0\n"
        requirements += "pytest-cov>=4.0\n"
        requirements += "black>=23.0\n"
        requirements += "flake8>=5.0\n"
        requirements += "mypy>=1.0\n"
        
        return requirements
    
    @staticmethod
    def generate_tox_ini(spec: Dict[str, Any]) -> str:
        """Generate tox.ini for testing multiple Python versions"""
        app_name = spec.get("name", "app")
        
        tox_ini = f'''[tox]
envlist = py39,py310,py311,lint,type

[testenv]
description = Run unit tests with pytest
extras = test
commands =
    pytest {{posargs:tests/}}

[testenv:lint]
description = Run code quality checks
extras = dev
commands =
    black --check {app_name} tests
    flake8 {app_name} tests
    isort --check-only {app_name} tests

[testenv:format]
description = Format code with black and isort
extras = dev
commands =
    black {app_name} tests
    isort {app_name} tests

[testenv:type]
description = Run type checking with mypy
extras = dev
commands =
    mypy {app_name}

[testenv:coverage]
description = Generate coverage report
extras = test
commands =
    pytest --cov={app_name} --cov-report=html --cov-report=term-missing tests/

[flake8]
max-line-length = 100
exclude = .git,__pycache__,.venv,build,dist
ignore = E203,W503

[pytest]
testpaths = tests
python_files = test_*.py *_test.py
'''
        return tox_ini
    
    @staticmethod
    def generate_gitignore() -> str:
        """Generate .gitignore for Python project"""
        gitignore = """# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Unit test / coverage
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Sphinx documentation
docs/_build/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Virtual environments
.venv/
venv/
ENV/
env/

# Environment variables
.env
.env.local

# Generated
dist/
build/
*.whl
"""
        return gitignore


class PythonFileGenerator:
    """Generates individual Python files"""
    
    @staticmethod
    def generate_main_module(spec: Dict[str, Any]) -> str:
        """Generate main module __init__.py"""
        app_name = spec.get("name", "app")
        version = "1.0.0"
        description = spec.get("description", "")
        
        main_init = f'''"""
{app_name}: {description}

A Python application generated with AWS Bedrock.
"""

__version__ = "{version}"
__author__ = "Generated by Bedrock"
__all__ = ["__version__"]

import logging

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())
'''
        return main_init
    
    @staticmethod
    def generate_config_module(spec: Dict[str, Any]) -> str:
        """Generate config module"""
        config_module = f'''"""
Configuration management module
"""

import os
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class Config:
    """
    Application configuration
    
    Configuration can be overridden using environment variables.
    """
    
    # Base configuration
    DEBUG = os.getenv("DEBUG", "False").lower() == "true"
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
    
    # Application metadata
    APP_NAME = "{spec.get('name', 'app')}"
    APP_VERSION = "1.0.0"
    APP_TYPE = "{spec.get('app_type', 'api')}"
    
    # Paths
    BASE_DIR = Path(__file__).parent.parent
    DATA_DIR = BASE_DIR / "data"
    LOG_DIR = BASE_DIR / "logs"
    
    @classmethod
    def init_app(cls):
        """Initialize application configuration"""
        # Create required directories
        cls.DATA_DIR.mkdir(exist_ok=True, parents=True)
        cls.LOG_DIR.mkdir(exist_ok=True, parents=True)
        
        logger.info(f"Initialized configuration for {{cls.APP_NAME}}")
        logger.debug(f"Debug mode: {{cls.DEBUG}}")


class DevelopmentConfig(Config):
    """Development configuration"""
    DEBUG = True
    LOG_LEVEL = "DEBUG"


class ProductionConfig(Config):
    """Production configuration"""
    DEBUG = False
    LOG_LEVEL = "WARNING"


class TestingConfig(Config):
    """Testing configuration"""
    DEBUG = True
    LOG_LEVEL = "DEBUG"
    TESTING = True


def get_config(env: Optional[str] = None) -> Config:
    """
    Get configuration based on environment
    
    Args:
        env: Environment name (development, production, testing)
        
    Returns:
        Configuration object
    """
    env = env or os.getenv("ENV", "development")
    
    configs = {{
        "development": DevelopmentConfig,
        "production": ProductionConfig,
        "testing": TestingConfig,
    }}
    
    config_class = configs.get(env.lower(), DevelopmentConfig)
    logger.info(f"Using {{env}} configuration")
    return config_class()
'''
        return config_module
    
    @staticmethod
    def generate_cli_module(spec: Dict[str, Any]) -> str:
        """Generate CLI module"""
        app_name = spec.get("name", "app")
        
        cli_module = f'''"""
Command-line interface for {app_name}
"""

import argparse
import logging
import sys
from pathlib import Path

from . import __version__
from .config import get_config

logger = logging.getLogger(__name__)


def setup_logging(log_level: str) -> None:
    """
    Setup logging configuration
    
    Args:
        log_level: Logging level
    """
    logging.basicConfig(
        level=getattr(logging, log_level.upper(), logging.INFO),
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )


def main() -> int:
    """
    Main CLI entry point
    
    Returns:
        Exit code
    """
    parser = argparse.ArgumentParser(
        description="{spec.get('description', '')}",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {{__version__}}",
    )
    
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Enable verbose logging",
    )
    
    parser.add_argument(
        "--config",
        "-c",
        type=str,
        help="Configuration file path",
    )
    
    args = parser.parse_args()
    
    # Setup logging
    log_level = "DEBUG" if args.verbose else "INFO"
    setup_logging(log_level)
    
    logger.info(f"Starting {{app_name}} v{{__version__}}")
    
    # Load configuration
    config = get_config()
    config.init_app()
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
'''
        return cli_module
    
    @staticmethod
    def generate_test_file(spec: Dict[str, Any]) -> str:
        """Generate test_main.py"""
        app_name = spec.get("name", "app").replace("-", "_")
        
        test_main = f'''"""
Unit tests for {app_name}
"""

import pytest
from pathlib import Path
import sys

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from {app_name}.config import Config, get_config, DevelopmentConfig


class TestConfig:
    """Test configuration management"""
    
    def test_config_exists(self):
        """Test that config can be instantiated"""
        config = get_config()
        assert config is not None
    
    def test_development_config(self):
        """Test development configuration"""
        config = DevelopmentConfig()
        assert config.DEBUG is True
        assert config.LOG_LEVEL == "DEBUG"
    
    def test_config_paths(self):
        """Test that config paths are created"""
        config = Config()
        config.init_app()
        
        assert config.DATA_DIR.exists()
        assert config.LOG_DIR.exists()


@pytest.fixture
def config():
    """Fixture providing configuration"""
    return get_config()


def test_config_fixture(config):
    """Test configuration fixture"""
    assert config is not None
    assert hasattr(config, "APP_NAME")
    assert hasattr(config, "DEBUG")
'''
        return test_main
