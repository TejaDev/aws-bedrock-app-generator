"""
Python specific project generator
"""

from pathlib import Path
from typing import Dict, Any
import logging

logger = logging.getLogger(__name__)


class PythonProjectGenerator:
    """Generates production-ready Python projects"""
    
    @staticmethod
    def get_project_structure(spec: Dict[str, Any]) -> Dict[str, str]:
        """Get standard Python project structure"""
        app_name = spec.get("name", "app").replace("-", "_")
        
        return {
            f"{app_name}": "Main package",
            f"{app_name}/core": "Core functionality",
            f"{app_name}/config": "Configuration",
            f"{app_name}/utils": "Utility functions",
            "tests": "Test suite",
            "tests/unit": "Unit tests",
            "tests/integration": "Integration tests",
            "docs": "Documentation",
            ".github/workflows": "GitHub Actions CI/CD",
        }
    
    @staticmethod
    def generate_setup_py(spec: Dict[str, Any]) -> str:
        """Generate setup.py for the Python package"""
        app_name = spec.get("name", "app")
        description = spec.get("description", "")
        dependencies = spec.get("dependencies", [])
        
        deps_str = ",\n        ".join([f'"{dep}"' for dep in dependencies])
        
        setup_py = f'''"""
Setup configuration for {app_name}
"""

from setuptools import setup, find_packages

setup(
    name="{app_name}",
    version="1.0.0",
    description="{description}",
    author="Generated by Bedrock",
    author_email="noreply@example.com",
    license="MIT",
    packages=find_packages(exclude=["tests", "tests.*"]),
    python_requires=">=3.9",
    install_requires=[
        {deps_str if deps_str else "'requests'"}
    ],
    extras_require={{
        "dev": [
            "pytest>=7.0",
            "pytest-cov>=4.0",
            "black>=23.0",
            "flake8>=5.0",
            "mypy>=1.0",
            "sphinx>=5.0",
        ],
        "test": [
            "pytest>=7.0",
            "pytest-cov>=4.0",
            "pytest-mock>=3.0",
        ],
    }},
    entry_points={{
        "console_scripts": [
            "{app_name}={app_name}.cli:main",
        ],
    }},
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
    ],
)
'''
        return setup_py
    
    @staticmethod
    def generate_pyproject_toml(spec: Dict[str, Any]) -> str:
        """Generate pyproject.toml for the Python package"""
        app_name = spec.get("name", "app")
        description = spec.get("description", "")
        
        pyproject = f'''[build-system]
requires = ["setuptools>=65.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "{app_name}"
version = "1.0.0"
description = "{description}"
readme = "README.md"
requires-python = ">=3.9"
license = {{text = "MIT"}}
authors = [
    {{name = "Generated by Bedrock", email = "noreply@example.com"}}
]
keywords = ["generated", "bedrock", "aws"]

[project.urls]
Homepage = "https://github.com/yourusername/{app_name}"
Documentation = "https://github.com/yourusername/{app_name}/docs"
Repository = "https://github.com/yourusername/{app_name}.git"
"Bug Tracker" = "https://github.com/yourusername/{app_name}/issues"

[tool.setuptools]
packages = ["setuptools.find_packages"]

[tool.black]
line-length = 100
target-version = ["py39", "py310", "py311"]
include = "\\\\.pyi?$"
exclude = "(.git|__pycache__|.mypy_cache|.tox|.venv|_build|buck-out|build|dist)"

[tool.isort]
profile = "black"
multi_line_mode = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true
line_length = 100

[tool.mypy]
python_version = "3.9"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = false

[tool.pytest.ini_options]
testpaths = ["tests"]
addopts = "-v --cov={app_name} --cov-report=html --cov-report=term-missing"
python_files = ["test_*.py", "*_test.py"]
'''
        return pyproject
    
    @staticmethod
    def generate_requirements_txt(spec: Dict[str, Any]) -> str:
        """Generate requirements.txt"""
        dependencies = spec.get("dependencies", [])
        
        # Built-in Python modules that should not be in requirements.txt
        builtin_modules = {
            "logging", "sys", "os", "json", "re", "datetime", "time",
            "collections", "itertools", "functools", "threading", "asyncio",
            "pathlib", "typing", "enum", "abc", "collections.abc",
            "unittest", "doctest", "pdb", "traceback", "warnings",
            "io", "codecs", "pickle", "csv", "configparser", "argparse",
            "logging.config", "hashlib", "hmac", "secrets", "base64",
            "urllib", "urllib.parse", "http", "http.client", "email",
            "socket", "ssl", "select", "signal", "subprocess", "shutil",
            "tempfile", "glob", "fnmatch", "linecache", "struct", "dis",
            "inspect", "types", "copy", "pprint", "reprlib", "math",
            "cmath", "decimal", "fractions", "random", "statistics"
        }
        
        # Known non-existent packages that Bedrock sometimes generates
        invalid_packages = {
            "python-camunda",  # Bedrock generates this, doesn't exist
            "workflow-engine",  # Not a real package
            "task-scheduler",   # Not a real package
            "orchestration-framework",  # Not a real package
        }
        
        # Filter out built-in modules and invalid packages
        filtered_deps = []
        for dep in dependencies:
            # Extract package name (before any version specifiers)
            pkg_name = dep.split(">=")[0].split("==")[0].split("<")[0].split(">")[0].split("~")[0].split("!")[0].strip().lower()
            
            if pkg_name not in builtin_modules and pkg_name not in invalid_packages:
                filtered_deps.append(dep)
        
        # Always include core FastAPI dependencies for API projects
        core_deps = {
            "fastapi",
            "uvicorn",
            "pydantic",
            "python-dotenv",
            "sqlalchemy",
            "requests"
        }
        
        requirements = "# Generated Python Dependencies\n"
        requirements += "# Core Dependencies\n"
        
        # Add core dependencies first
        for core_dep in core_deps:
            requirements += f"{core_dep}\n"
        
        # Add any additional filtered dependencies that aren't core
        for dep in filtered_deps:
            pkg_name = dep.split(">=")[0].split("==")[0].split("<")[0].split(">")[0].split("~")[0].split("!")[0].strip().lower()
            if pkg_name not in core_deps:
                requirements += f"{dep}\n"
        
        requirements += "\n# Development Dependencies\n"
        requirements += "pytest>=7.0\n"
        requirements += "pytest-cov>=4.0\n"
        requirements += "black>=23.0\n"
        requirements += "flake8>=5.0\n"
        requirements += "mypy>=1.0\n"
        
        return requirements
    
    @staticmethod
    def generate_tox_ini(spec: Dict[str, Any]) -> str:
        """Generate tox.ini for testing multiple Python versions"""
        app_name = spec.get("name", "app")
        
        tox_ini = f'''[tox]
envlist = py39,py310,py311,lint,type

[testenv]
description = Run unit tests with pytest
extras = test
commands =
    pytest {{posargs:tests/}}

[testenv:lint]
description = Run code quality checks
extras = dev
commands =
    black --check {app_name} tests
    flake8 {app_name} tests
    isort --check-only {app_name} tests

[testenv:format]
description = Format code with black and isort
extras = dev
commands =
    black {app_name} tests
    isort {app_name} tests

[testenv:type]
description = Run type checking with mypy
extras = dev
commands =
    mypy {app_name}

[testenv:coverage]
description = Generate coverage report
extras = test
commands =
    pytest --cov={app_name} --cov-report=html --cov-report=term-missing tests/

[flake8]
max-line-length = 100
exclude = .git,__pycache__,.venv,build,dist
ignore = E203,W503

[pytest]
testpaths = tests
python_files = test_*.py *_test.py
'''
        return tox_ini
    
    @staticmethod
    def generate_gitignore() -> str:
        """Generate .gitignore for Python project"""
        gitignore = """# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Unit test / coverage
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Sphinx documentation
docs/_build/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Virtual environments
.venv/
venv/
ENV/
env/

# Environment variables
.env
.env.local

# Generated
dist/
build/
*.whl
"""
        return gitignore


class PythonFileGenerator:
    """Generates individual Python files"""
    
    @staticmethod
    def generate_main_module(spec: Dict[str, Any]) -> str:
        """Generate main module __init__.py"""
        app_name = spec.get("name", "app")
        version = "1.0.0"
        description = spec.get("description", "")
        
        main_init = f'''"""
{app_name}: {description}

A Python application generated with AWS Bedrock.
"""

__version__ = "{version}"
__author__ = "Generated by Bedrock"
__all__ = ["__version__"]

import logging

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())
'''
        return main_init
    
    @staticmethod
    def generate_config_module(spec: Dict[str, Any]) -> str:
        """Generate config module"""
        config_module = f'''"""
Configuration management module
"""

import os
from pathlib import Path
from typing import Optional
import logging

logger = logging.getLogger(__name__)


class Config:
    """
    Application configuration
    
    Configuration can be overridden using environment variables.
    """
    
    # Base configuration
    DEBUG = os.getenv("DEBUG", "False").lower() == "true"
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
    
    # Application metadata
    APP_NAME = "{spec.get('name', 'app')}"
    APP_VERSION = "1.0.0"
    APP_TYPE = "{spec.get('app_type', 'api')}"
    
    # Paths
    BASE_DIR = Path(__file__).parent.parent
    DATA_DIR = BASE_DIR / "data"
    LOG_DIR = BASE_DIR / "logs"
    
    @classmethod
    def init_app(cls):
        """Initialize application configuration"""
        # Create required directories
        cls.DATA_DIR.mkdir(exist_ok=True, parents=True)
        cls.LOG_DIR.mkdir(exist_ok=True, parents=True)
        
        logger.info(f"Initialized configuration for {{cls.APP_NAME}}")
        logger.debug(f"Debug mode: {{cls.DEBUG}}")


class DevelopmentConfig(Config):
    """Development configuration"""
    DEBUG = True
    LOG_LEVEL = "DEBUG"


class ProductionConfig(Config):
    """Production configuration"""
    DEBUG = False
    LOG_LEVEL = "WARNING"


class TestingConfig(Config):
    """Testing configuration"""
    DEBUG = True
    LOG_LEVEL = "DEBUG"
    TESTING = True


def get_config(env: Optional[str] = None) -> Config:
    """
    Get configuration based on environment
    
    Args:
        env: Environment name (development, production, testing)
        
    Returns:
        Configuration object
    """
    env = env or os.getenv("ENV", "development")
    
    configs = {{
        "development": DevelopmentConfig,
        "production": ProductionConfig,
        "testing": TestingConfig,
    }}
    
    config_class = configs.get(env.lower(), DevelopmentConfig)
    logger.info(f"Using {{env}} configuration")
    return config_class()
'''
        return config_module
    
    @staticmethod
    def generate_cli_module(spec: Dict[str, Any]) -> str:
        """Generate CLI module"""
        app_name = spec.get("name", "app")
        
        cli_module = f'''"""
Command-line interface for {app_name}
"""

import argparse
import logging
import sys
from pathlib import Path

from . import __version__
from .config import get_config

logger = logging.getLogger(__name__)


def setup_logging(log_level: str) -> None:
    """
    Setup logging configuration
    
    Args:
        log_level: Logging level
    """
    logging.basicConfig(
        level=getattr(logging, log_level.upper(), logging.INFO),
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )


def main() -> int:
    """
    Main CLI entry point
    
    Returns:
        Exit code
    """
    parser = argparse.ArgumentParser(
        description="{spec.get('description', '')}",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {{__version__}}",
    )
    
    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Enable verbose logging",
    )
    
    parser.add_argument(
        "--config",
        "-c",
        type=str,
        help="Configuration file path",
    )
    
    args = parser.parse_args()
    
    # Setup logging
    log_level = "DEBUG" if args.verbose else "INFO"
    setup_logging(log_level)
    
    logger.info(f"Starting {{app_name}} v{{__version__}}")
    
    # Load configuration
    config = get_config()
    config.init_app()
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
'''
        return cli_module
    
    @staticmethod
    def generate_test_file(spec: Dict[str, Any]) -> str:
        """Generate test_main.py"""
        app_name = spec.get("name", "app").replace("-", "_")
        
        test_main = f'''"""
Unit tests for {app_name}
"""

import pytest
from pathlib import Path
import sys

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from {app_name}.config import Config, get_config, DevelopmentConfig


class TestConfig:
    """Test configuration management"""
    
    def test_config_exists(self):
        """Test that config can be instantiated"""
        config = get_config()
        assert config is not None
    
    def test_development_config(self):
        """Test development configuration"""
        config = DevelopmentConfig()
        assert config.DEBUG is True
        assert config.LOG_LEVEL == "DEBUG"
    
    def test_config_paths(self):
        """Test that config paths are created"""
        config = Config()
        config.init_app()
        
        assert config.DATA_DIR.exists()
        assert config.LOG_DIR.exists()


@pytest.fixture
def config():
    """Fixture providing configuration"""
    return get_config()


def test_config_fixture(config):
    """Test configuration fixture"""
    assert config is not None
    assert hasattr(config, "APP_NAME")
    assert hasattr(config, "DEBUG")
'''
        return test_main
    
    @staticmethod
    def generate_main_entry_point(spec: Dict[str, Any]) -> str:
        """Generate __main__.py entry point for package execution"""
        app_name = spec.get("name", "app").replace("-", "_")
        description = spec.get("description", "")
        
        main_entry = f'''"""
Main entry point for {app_name}
Allows running the package as: python -m {app_name}
"""

import sys
import logging
from pathlib import Path

# Add parent directory to sys.path to allow imports from src
sys.path.insert(0, str(Path(__file__).parent.parent))

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)

logger = logging.getLogger(__name__)


def main() -> int:
    """
    Main entry point
    
    Returns:
        Exit code
    """
    try:
        logger.info("Starting {app_name}...")
        
        # Import and run the main application
        from .main import app
        
        # Run FastAPI app with uvicorn
        import uvicorn
        uvicorn.run(
            app,
            host="0.0.0.0",
            port=5000,
            log_level="info",
        )
        
        return 0
    except Exception as e:
        logger.error(f"Error running application: {{e}}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())
'''
        return main_entry
    
    @staticmethod
    def generate_routes_module() -> str:
        """Generate API routes module"""
        routes = '''"""
API routes for the application
"""

from fastapi import APIRouter, Depends, HTTPException, status
from typing import Dict, Any, Optional

router = APIRouter()


@router.get("/health", tags=["health"])
async def health_check() -> Dict[str, Any]:
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "api"
    }


@router.get("/", tags=["root"])
async def root() -> Dict[str, str]:
    """Root endpoint"""
    return {"message": "Welcome to the API"}
'''
        return routes
    
    @staticmethod
    def generate_jwt_middleware_module() -> str:
        """Generate JWT middleware module"""
        middleware = '''"""
JWT authentication middleware
"""

from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from typing import Callable, Awaitable


class JWTMiddleware(BaseHTTPMiddleware):
    """JWT authentication middleware"""
    
    async def dispatch(self, request: Request, call_next: Callable[[Request], Awaitable]) -> Awaitable:
        """Process request with JWT validation"""
        # Skip authentication for health checks and docs
        skip_paths = ["/health", "/docs", "/openapi.json", "/"]
        if any(request.url.path.startswith(path) for path in skip_paths):
            return await call_next(request)
        
        # TODO: Implement JWT validation
        response = await call_next(request)
        return response
'''
        return middleware
    
    @staticmethod
    def generate_exceptions_module() -> str:
        """Generate custom exceptions module"""
        exceptions = '''"""
Custom exception classes
"""


class AuthenticationError(Exception):
    """Raised when authentication fails"""
    pass


class AuthorizationError(Exception):
    """Raised when authorization fails"""
    pass


class ValidationError(Exception):
    """Raised when validation fails"""
    pass


class NotFoundError(Exception):
    """Raised when resource is not found"""
    pass
'''
        return exceptions
    
    @staticmethod
    def generate_database_module() -> str:
        """Generate database module"""
        database = '''"""
Database models and initialization
"""

from typing import AsyncGenerator, Optional
import logging

logger = logging.getLogger(__name__)


async def init_db() -> None:
    """Initialize database connection"""
    logger.info("Initializing database...")
    # TODO: Implement database initialization
    pass


async def close_db() -> None:
    """Close database connection"""
    logger.info("Closing database connection...")
    # TODO: Implement database cleanup
    pass


async def get_db() -> AsyncGenerator:
    """Database session dependency"""
    # TODO: Implement database session management
    yield
'''
        return database
    
    @staticmethod
    def generate_logger_module() -> str:
        """Generate logging utilities module"""
        logger_module = '''"""
Logging utilities for the application
"""

import logging
from typing import Optional


def setup_logging(level: Optional[str] = None) -> logging.Logger:
    """
    Setup and configure logging
    
    Args:
        level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        
    Returns:
        Configured logger instance
    """
    level = level or logging.INFO
    
    # Create logger
    logger = logging.getLogger(__name__)
    logger.setLevel(level)
    
    # Create console handler
    handler = logging.StreamHandler()
    handler.setLevel(level)
    
    # Create formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)
    
    # Add handler to logger
    if not logger.handlers:
        logger.addHandler(handler)
    
    return logger
'''
        return logger_module
    
    @staticmethod
    def generate_validators_module() -> str:
        """Generate data validators module"""
        validators = '''"""
Data validation utilities
"""

import re
from typing import Any, Dict, List, Optional


def validate_email(email: str) -> bool:
    """
    Validate email address format
    
    Args:
        email: Email address to validate
        
    Returns:
        True if valid, False otherwise
    """
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))


def validate_required_fields(data: Dict[str, Any], required_fields: List[str]) -> bool:
    """
    Validate that required fields are present
    
    Args:
        data: Dictionary to validate
        required_fields: List of required field names
        
    Returns:
        True if all required fields present, False otherwise
    """
    return all(field in data and data[field] is not None for field in required_fields)


def validate_string_length(value: str, min_length: int = 0, max_length: Optional[int] = None) -> bool:
    """
    Validate string length
    
    Args:
        value: String to validate
        min_length: Minimum length
        max_length: Maximum length (None for unlimited)
        
    Returns:
        True if valid, False otherwise
    """
    if len(value) < min_length:
        return False
    if max_length and len(value) > max_length:
        return False
    return True
'''
        return validators
    
    @staticmethod
    def generate_fastapi_main(spec: Dict[str, Any]) -> str:
        """Generate main.py for FastAPI applications"""
        app_name = spec.get("name", "app").replace("-", "_")
        description = spec.get("description", "API")
        
        main = f'''#!/usr/bin/env python3
"""
Main application entry point for {app_name}.
Configures and starts the FastAPI application with all required middleware and routes.
"""
import logging
from typing import Dict, Any
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

# Import routes from static generator
from src.api.routes import router

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="{app_name}",
    description="{description}",
    version="1.0.0",
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(router)

# Custom exception handlers
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle validation errors"""
    return JSONResponse(
        status_code=422,
        content={{"detail": exc.errors(), "body": exc.body}},
    )

# Root endpoint
@app.get("/", tags=["root"])
async def root() -> Dict[str, str]:
    """Root endpoint"""
    return {{"message": "Welcome to {app_name}"}}

# Health check endpoint
@app.get("/health", tags=["health"])
async def health() -> Dict[str, str]:
    """Health check endpoint"""
    return {{"status": "healthy", "service": "{app_name}"}}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=5000, log_level="info")
'''
        return main
    
    @staticmethod
    def generate_helpers_module() -> str:
        """Generate helper functions module"""
        helpers = '''"""
Helper utilities and common functions
"""

from typing import Any, Dict, List, Optional
from datetime import datetime, timedelta


def get_current_timestamp() -> str:
    """Get current timestamp as ISO format string"""
    return datetime.utcnow().isoformat()


def parse_timestamp(timestamp_str: str) -> Optional[datetime]:
    """
    Parse ISO format timestamp string
    
    Args:
        timestamp_str: ISO format timestamp string
        
    Returns:
        datetime object or None if parsing fails
    """
    try:
        return datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
    except (ValueError, AttributeError):
        return None


def get_time_difference(start_time: datetime, end_time: datetime) -> timedelta:
    """
    Get time difference between two datetime objects
    
    Args:
        start_time: Start datetime
        end_time: End datetime
        
    Returns:
        timedelta object representing the difference
    """
    return end_time - start_time


def dict_to_lowercase_keys(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Convert all dictionary keys to lowercase
    
    Args:
        data: Dictionary to convert
        
    Returns:
        New dictionary with lowercase keys
    """
    return {k.lower(): v for k, v in data.items()}


def flatten_dict(data: Dict[str, Any], parent_key: str = '', sep: str = '.') -> Dict[str, Any]:
    """
    Flatten nested dictionary
    
    Args:
        data: Dictionary to flatten
        parent_key: Parent key for nested items
        sep: Separator for nested keys
        
    Returns:
        Flattened dictionary
    """
    items = []
    for k, v in data.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)
'''
        return helpers
